if exists('g:loaded_pwn_ftplugin')
    finish
endif
let g:loaded_pwn_ftplugin = 1

" Run command
map <leader>r :!python %<CR>

" Insert some script line
function! exploit#insert_line(l, cmd, cur)
    let lnum = line('.')
    let line = getline(lnum)
    if strridx(line, a:cmd) != -1
        normal dd
    else
        if a:l == "next"
            let plnum = prevnonblank(lnum)
            let inum = lnum
        else
            let plnum = prevnonblank(lnum)
            let inum = lnum - 1
        endif
        let indentcount = indent(plnum)
        call append(inum, repeat(' ', indentcount).a:cmd)
        if a:cur == -1
            if a:l == "cur"
                normal k
            else
                normal j
            endif
        else
            call cursor(inum + 1, a:cur + indentcount)
        endif
    endif
endfunction
let g:pwn_gdb_cmd = 'gdb.attach(r)  # XXX: Attach GDB here'
map <leader>b :call exploit#insert_line("cur", g:pwn_gdb_cmd, -1)<CR>
let g:pwn_pause_cmd = 'pause()  # XXX: STOP here'
map <leader>p :call exploit#insert_line("cur", pwn_pause_cmd, -1)<CR>
map <leader>s :call exploit#insert_line("next", "r.send()", 8)<CR>
map <leader>e :call exploit#insert_line("next", "res = r.recv()", 14)<CR>
map <leader>a :call exploit#insert_line("next", "res = r.recvuntil(\"\")", 20)<CR>
map <leader>g :call exploit#insert_line("next", "gdb.attach(r, \"\"\"  \"\"\")", 19)<CR>

function! exploit#get_noindent_line(l)
    let lnum = line(a:l)
    let line = getline(lnum)
    return substitute(line, '^\s*\(.\{-}\)$', '\1', '')
endfunction

function! exploit#print_var()
    let line = exploit#get_noindent_line('.')
    let var = substitute(line, '^\([a-zA-Z0-9_]\+\).\{-}$', '\1', '')
    call exploit#insert_line("next", "print (".var.")", -1)
endfunction
map <leader>i :call exploit#print_var()<CR>

" Make command
function! exploit#comment()
    let lnum = line('.')
    let indentcount = indent(lnum)
    let no_indent_line = exploit#get_noindent_line('.')
    if strridx(no_indent_line, '# ') == 0
        normal ^2x
    else
        normal dd
        call append(lnum - 1, repeat(' ', indentcount).'# '.no_indent_line)
        normal k
    endif
endfunction
map <leader>m :call exploit#comment()<CR>

" File template
let g:pwn_template = get(g:, 'pwn_template', 1)
function! s:loadtemplate()
    call append(0, "from pwn import *")
    call append(1, "")
    call append(2, "\# r = remote('X', X)")
    call append(3, "r = process([''])")
    call append(4, "")
    call append(5, "")
    call append(6, "\# r.interactive()")
    call append(8, "\# exploit")
    call cursor(4, 15)
    set nomodified
    startinsert
    return 1
endfunction
function! s:isnewfile()
    return ( has('byte_offset') ? line2byte(1) == -1 : getline(1,2) == [''] )
        \ && ! &modified && ( g:pwn_template || ! filereadable(bufname('')) )
endfunction
if s:isnewfile() | call s:loadtemplate() | endif
